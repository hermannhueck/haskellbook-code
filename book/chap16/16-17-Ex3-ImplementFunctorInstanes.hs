-- 16-17-Ex3-ImplementFunctorInstanes.hs
--
-- 16.17 Chapter Exercises, page 679
-- Exercises, page 681
--
-- Write Functor instances for the following datatypes.
--
{-# LANGUAGE FlexibleInstances #-}

module ImplementFunctorInstanes where

import Test.Hspec
import Test.QuickCheck
import Test.QuickCheck.Function

-- properties for Functor laws
-- identity
functorIdentity :: (Functor f, Eq (f a)) => f a -> Bool
functorIdentity f = fmap id f == f

-- composition - only values generated by QuickCheck
functorCompose :: (Functor f, Eq (f c)) => (a -> b) -> (b -> c) -> f a -> Bool
functorCompose f g x = (fmap g (fmap f x)) == (fmap (g . f) x)

-- composition - QuickCheck generates the functions as well.
functorCompose' :: (Eq (f c), Functor f) => f a -> Fun a b -> Fun b c -> Bool
functorCompose' x (Fun _ f) (Fun _ g) =
  (fmap (g . f) x) == (fmap g . fmap f $ x)

type IntToInt = Fun Int Int

-- 1.
data Quant a b
  = Finance
  | Desk a
  | Bloor b
  deriving (Eq, Show)

instance Functor (Quant a) where
  fmap _ Finance = Finance
  fmap _ (Desk x) = Desk x
  fmap f (Bloor x) = Bloor (f x)

instance (Arbitrary a, Arbitrary b) => Arbitrary (Quant a b) where
  arbitrary = do
    x <- arbitrary
    y <- arbitrary
    oneof $ map return [Finance, Desk x, Bloor y]

quickCheck_Quant :: IO ()
quickCheck_Quant =
  hspec $ do
    describe "Validating Functor laws for 'Quant a b' ..." $ do
      it "Functor identity law should hold." $ do
        property (functorIdentity :: Quant Int Int -> Bool)
      it "Functor composition law should hold using functions (+1) and (*2)." $ do
        property ((functorCompose (+ 1) (* 2)) :: Quant Int Int -> Bool)
      it "Functor composition law should hold using arbitrary functions." $ do
        property
          (functorCompose' :: Quant Int Int -> IntToInt -> IntToInt -> Bool)

-- 2. No, it’s not interesting by itself.
data K a b =
  K a
  deriving (Eq, Show)

instance Functor (K a) where
  fmap _ (K x) = K x

instance Arbitrary a => Arbitrary (K a b) where
  arbitrary = do
    x <- arbitrary
    return $ K x

quickCheck_K :: IO ()
quickCheck_K =
  hspec $ do
    describe "Validating Functor laws for 'K a b' ..." $ do
      it "Functor identity law should hold." $ do
        property (functorIdentity :: K Int Int -> Bool)
      it "Functor composition law should hold using functions (+1) and (*2)." $ do
        property ((functorCompose (+ 1) (* 2)) :: K Int Int -> Bool)
      it "Functor composition law should hold using arbitrary functions." $ do
        property (functorCompose' :: K Int Int -> IntToInt -> IntToInt -> Bool)

-- 3.
newtype Flip f a b =
  Flip (f b a)
  deriving (Eq, Show)

newtype K' a b =
  K' a
  deriving (Eq, Show)

-- should remind you of an instance you've written before
instance Functor (Flip K' a) where
  fmap f (Flip (K' x)) = Flip $ K' $ f x

instance (Arbitrary a, Arbitrary b) => Arbitrary (Flip K' a b) where
  arbitrary = do
    x <- arbitrary
    return $ Flip $ K' x

quickCheck_Flip_K' :: IO ()
quickCheck_Flip_K' =
  hspec $ do
    describe "Validating Functor laws for 'Flip K' a b' ..." $ do
      it "Functor identity law should hold." $ do
        property (functorIdentity :: Flip K' Int Int -> Bool)
      it "Functor composition law should hold using functions (+1) and (*2)." $ do
        property ((functorCompose (+ 1) (* 2)) :: Flip K' Int Int -> Bool)
      it "Functor composition law should hold using arbitrary functions." $ do
        property
          (functorCompose' :: Flip K' Int Int -> IntToInt -> IntToInt -> Bool)

-- 4.
data EvilGoateeConst a b =
  GoatyConst b
  deriving (Eq, Show)

instance Functor (EvilGoateeConst a) where
  fmap f (GoatyConst x) = GoatyConst $ f x

instance (Arbitrary a, Arbitrary b) => Arbitrary (EvilGoateeConst a b) where
  arbitrary = do
    x <- arbitrary
    return $ GoatyConst x

quickCheck_EvilGoateeConst :: IO ()
quickCheck_EvilGoateeConst =
  hspec $ do
    describe "Validating Functor laws for 'EvilGoateeConst a b' ..." $ do
      it "Functor identity law should hold." $ do
        property (functorIdentity :: Quant Int Int -> Bool)
      it "Functor composition law should hold using functions (+1) and (*2)." $ do
        property ((functorCompose (+ 1) (* 2)) :: Quant Int Int -> Bool)
      it "Functor composition law should hold using arbitrary functions." $ do
        property
          (functorCompose' :: Quant Int Int -> IntToInt -> IntToInt -> Bool)

-- 5. Do you need something extra to make the instance work?
data LiftItOut f a =
  LiftItOut (f a)
  deriving (Eq, Show)

instance Functor f => Functor (LiftItOut f) where
  fmap g (LiftItOut f) = LiftItOut $ fmap g f

instance (Arbitrary a) => Arbitrary (LiftItOut Maybe a) where
  arbitrary = do
    x <- arbitrary
    oneof $ map return $ map LiftItOut [Nothing, Just x]

quickCheck_LiftItOut :: IO ()
quickCheck_LiftItOut =
  hspec $ do
    describe "Validating Functor laws for 'LiftItOut f a' ..." $ do
      it "Functor identity law should hold." $ do
        property (functorIdentity :: LiftItOut Maybe Int -> Bool)
      it "Functor composition law should hold using functions (+1) and (*2)." $ do
        property ((functorCompose (+ 1) (* 2)) :: LiftItOut Maybe Int -> Bool)
      it "Functor composition law should hold using arbitrary functions." $ do
        property
          (functorCompose' :: LiftItOut Maybe Int -> IntToInt -> IntToInt -> Bool)

-- 6.
data Parappa f g a =
  DaWrappa (f a)
           (g a)
  deriving (Eq, Show)

instance (Functor f, Functor g) => Functor (Parappa f g) where
  fmap m (DaWrappa f g) = DaWrappa (fmap m f) (fmap m g)

instance (Arbitrary a) => Arbitrary (Parappa Maybe Maybe a) where
  arbitrary = do
    x <- arbitrary
    y <- arbitrary
    oneof $
      map
        return
        [ (DaWrappa (Just x) (Just y))
        , (DaWrappa (Just x) Nothing)
        , (DaWrappa Nothing (Just y))
        , (DaWrappa Nothing Nothing)
        ]

quickCheck_Parappa :: IO ()
quickCheck_Parappa =
  hspec $ do
    describe "Validating Functor laws for 'Parappa f g a' ..." $ do
      it "Functor identity law should hold." $ do
        property (functorIdentity :: Parappa Maybe Maybe Int -> Bool)
      it "Functor composition law should hold using functions (+1) and (*2)." $ do
        property
          ((functorCompose (+ 1) (* 2)) :: Parappa Maybe Maybe Int -> Bool)
      it "Functor composition law should hold using arbitrary functions." $ do
        property
          (functorCompose' :: Parappa Maybe Maybe Int -> IntToInt -> IntToInt -> Bool)

-- 7. Don’t ask for more typeclass instances than you need. You can let GHC tell you what to do.
data IgnoreOne f g a b =
  IgnoringSomething (f a)
                    (g b)
  deriving (Eq, Show)

instance Functor g => Functor (IgnoreOne f g a) where
  fmap m (IgnoringSomething f g) = IgnoringSomething f (fmap m g)

instance (Arbitrary a, Arbitrary b) =>
         Arbitrary (IgnoreOne Maybe Maybe a b) where
  arbitrary = do
    x <- arbitrary
    y <- arbitrary
    oneof $
      map return [(IgnoringSomething x (Just y)), (IgnoringSomething x Nothing)]

quickCheck_IgnoreOne :: IO ()
quickCheck_IgnoreOne =
  hspec $ do
    describe "Validating Functor laws for 'IgnoreOne f g a b' ..." $ do
      it "Functor identity law should hold." $ do
        property (functorIdentity :: IgnoreOne Maybe Maybe Int Int -> Bool)
      it "Functor composition law should hold using functions (+1) and (*2)." $ do
        property
          ((functorCompose (+ 1) (* 2)) :: IgnoreOne Maybe Maybe Int Int -> Bool)
      it "Functor composition law should hold using arbitrary functions." $ do
        property
          (functorCompose' :: IgnoreOne Maybe Maybe Int Int -> IntToInt -> IntToInt -> Bool)

-- 8.
data Notorious g o a t =
  Notorious (g o)
            (g a)
            (g t)
  deriving (Eq, Show)

instance Functor g => Functor (Notorious g o a) where
  fmap m (Notorious go ga gt) = Notorious go ga (fmap m gt)

instance (Arbitrary o, Arbitrary a, Arbitrary t) =>
         Arbitrary (Notorious Maybe o a t) where
  arbitrary = do
    go <- arbitrary
    ga <- arbitrary
    gt <- arbitrary
    oneof $ map return [(Notorious go ga (Just gt)), (Notorious go ga Nothing)]

quickCheck_Notorious :: IO ()
quickCheck_Notorious =
  hspec $ do
    describe "Validating Functor laws for 'Notorious g o a t' ..." $ do
      it "Functor identity law should hold." $ do
        property (functorIdentity :: Notorious Maybe Int Int Int -> Bool)
      it "Functor composition law should hold using functions (+1) and (*2)." $ do
        property
          ((functorCompose (+ 1) (* 2)) :: Notorious Maybe Int Int Int -> Bool)
      it "Functor composition law should hold using arbitrary functions." $ do
        property
          (functorCompose' :: Notorious Maybe Int Int Int -> IntToInt -> IntToInt -> Bool)

-- 9. You’ll need to use recursion.
data List a
  = Nil
  | Cons a
         (List a)
  deriving (Eq, Show)

instance Functor List where
  fmap _ Nil = Nil
  fmap f (Cons x xs) = Cons (f x) (fmap f xs)

instance Arbitrary a => Arbitrary (List a) where
  arbitrary = do
    x <- arbitrary
    xs <- arbitrary
    frequency $ zip [1, 8] $ map return [Nil, Cons x xs]

quickCheck_List :: IO ()
quickCheck_List =
  hspec $ do
    describe "Validating Functor laws for 'List a' ..." $ do
      it "Functor identity law should hold." $ do
        property (functorIdentity :: List Int -> Bool)
      it "Functor composition law should hold using functions (+1) and (*2)." $ do
        property ((functorCompose (+ 1) (* 2)) :: List Int -> Bool)
      it "Functor composition law should hold using arbitrary functions." $ do
        property (functorCompose' :: List Int -> IntToInt -> IntToInt -> Bool)

-- 10. A tree of goats forms a Goat-Lord, fearsome poly-creature.
data GoatLord a
  = NoGoat
  | OneGoat a
  | MoreGoats (GoatLord a)
              (GoatLord a)
              (GoatLord a)
  deriving (Eq, Show)

-- A VERITABLE HYDRA OF GOATS
instance Functor GoatLord where
  fmap _ NoGoat = NoGoat
  fmap f (OneGoat x) = OneGoat (f x)
  fmap f (MoreGoats glx gly glz) =
    MoreGoats (fmap f glx) (fmap f gly) (fmap f glz)

instance Arbitrary a => Arbitrary (GoatLord a) where
  arbitrary = do
    x <- arbitrary
    gl1 <- arbitrary
    gl2 <- arbitrary
    gl3 <- arbitrary
    frequency $
      zip [2, 2, 1] $ map return [NoGoat, OneGoat x, MoreGoats gl1 gl2 gl3]
        -- recursive invocation of arbitrary may hang in an infinite loop
        -- but in most cases it works fine.

quickCheck_GoatLord :: IO ()
quickCheck_GoatLord =
  hspec $ do
    describe "Validating Functor laws for 'GoatLord' ..." $ do
      it "Functor identity law should hold." $ do
        property (functorIdentity :: GoatLord Int -> Bool)
      it "Functor composition law should hold using functions (+1) and (*2)." $ do
        property ((functorCompose (+ 1) (* 2)) :: GoatLord Int -> Bool)
      it "Functor composition law should hold using arbitrary functions." $ do
        property
          (functorCompose' :: GoatLord Int -> IntToInt -> IntToInt -> Bool)

-- 11. You’ll use an extra functor for this one, although your solution might do it
-- monomorphically without using fmap. Keep in mind that you will probably not be able
-- to validate this one in the usual manner. Do your best to make it work.
data TalkToMe a
  = Halt
  | Print String
          a
  | Read (String -> a)

--    deriving (Eq, Show)
-- Don't know how to implement instances of Eq and Show for data constructor Read
instance Functor TalkToMe where
  fmap _ Halt = Halt
  fmap f (Print s x) = Print s $ f x
  fmap f (Read s2a) = Read (f . s2a)

instance Arbitrary a => Arbitrary (TalkToMe a) where
  arbitrary = do
    s <- arbitrary
    x <- arbitrary
    s2a <- arbitrary
    frequency $ zip [1, 1, 1] $ map return [Halt, Print s x, Read s2a]

-- Implementation neads an instance of Eq and Show for TalkToMe
-- Cannot be implemented easily for data constructor Read
--
-- quickCheck_TalkToMe :: IO ()
-- quickCheck_TalkToMe = hspec $ do
--     describe "Validating Functor laws for 'TalkToMe' ..." $ do
--         it "Functor identity law should hold." $ do
--             property (functorIdentity :: TalkToMe Int -> Bool)
--         it "Functor composition law should hold using functions (+1) and (*2)." $ do
--             property ((functorCompose (+1) (*2)) :: TalkToMe Int -> Bool)
--         it "Functor composition law should hold using arbitrary functions." $ do
--             property (functorCompose' :: TalkToMe Int -> IntToInt -> IntToInt -> Bool)
--
--
main :: IO ()
main = do
  quickCheck_Quant
  quickCheck_K
  quickCheck_Flip_K'
  quickCheck_EvilGoateeConst
  quickCheck_LiftItOut
  quickCheck_Parappa
  quickCheck_IgnoreOne
  quickCheck_Notorious
  quickCheck_List
  quickCheck_GoatLord
    -- quickCheck_TalkToMe
